---
title: Kubernetes 개념
author: dejavuhyo
date: 2021-02-02 10:15:00 +0900
categories: [DevOps, Kubernetes]
tags: [kubernetes, 쿠버네티스]
---

## 1. Kubernetes란

![img001](/assets/img/2021-02-02-kubernetes/img001.png)

컨테이너를 도입하는 조직이 점점 많아짐에 따라 컨테이너 중심 관리 소프트웨어인 Kubernetes는 사실상 컨테이너화된 애플리케이션을 배포하고 운영하기 위한 표준이 되었다. Kubernetes는 원래 Google에서 개발되어 2014년에 오픈소스로 출시되었으므로 Google Cloud가 시초라고 할 수 있다. Kubernetes는 15년 동안 축적된 Google의 컨테이너화된 워크로드 실행 경험과 오픈소스 커뮤니티의 소중한 기여를 기반으로 성장했다. Google의 내부 클러스터 관리 시스템인 Borg에서 영감을 얻어 시작된 Kubernetes를 사용하면 애플리케이션의 배포 및 관리와 관련된 모든 작업이 한층 간편해진다. 자동화된 컨테이너 조정 기능을 제공하는 Kubernetes는 안정성을 개선하고 일상적인 작업에 소요되는 시간과 리소스를 절감해 준다.

Kubernetes는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 오픈소스 플랫폼이다. Kubernetes는 선언적 구성과 자동화를 모두 용이하게 해준다. Kubernetes는 크고, 빠르게 성장하는 생태계를 가지고 있다. Kubernetes 서비스, 기술 지원 및 도구는 어디서나 쉽게 이용할 수 있다.

Kubernetes란 명칭은 키잡이(helmsman)나 파일럿을 뜻하는 그리스어에서 유래했다. 구글이 2014년에 Kubernetes 프로젝트를 오픈소스화했다. Kubernetes는 프로덕션 워크로드를 대규모로 운영하는 15년 이상의 구글 경험과 커뮤니티의 최고의 아이디어와 적용 사례가 결합되어 있다.

## 2. Kubernetes의 정의
Kubernetes('K'와 's' 사이의 문자 수를 나타내는 8을 사용하여 K8s로 줄여 쓰기도 함)는 컨테이너화된 애플리케이션을 어디서나 배포, 확장, 관리할 수 있는 오픈소스 시스템이다.

Kubernetes는 컨테이너 관리의 운영 작업을 자동화하며 애플리케이션 배포, 애플리케이션 변경사항 출시, 변화하는 요구 사항에 맞춘 애플리케이션 확장 및 축소, 애플리케이션 모니터링 등을 위한 기본 제공 명령을 포함하고 있으므로 이를 통해 애플리케이션을 보다 쉽게 관리할 수 있다.

## 3. 발전과정
시간이 지나면서 Kubernetes가 왜 유용하게 되었는지 살펴보자.

![img002](/assets/img/2021-02-02-kubernetes/img002.png)

### 1) 전통적인 배포 시대
초기 조직은 애플리케이션을 물리 서버에서 실행했었다. 한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 없었기에, 리소스 할당의 문제가 발생했다. 예를 들어 물리 서버 하나에서 여러 애플리케이션을 실행하면, 리소스 전부를 차지하는 애플리케이션 인스턴스가 있을 수 있고, 결과적으로는 다른 애플리케이션의 성능이 저하될 수 있었다. 이에 대한 해결책은 서로 다른 여러 물리 서버에서 각 애플리케이션을 실행하는 것이 있다. 그러나 이는 리소스가 충분히 활용되지 않는다는 점에서 확장 가능하지 않았으므로, 물리 서버를 많이 유지하기 위해서 조직에게 많은 비용이 들었다.

### 2) 가상화된 배포 시대
그 해결책으로 가상화가 도입되었다. 이는 단일 물리 서버의 CPU에서 여러 가상 시스템 (VM)을 실행할 수 있게 한다. 가상화를 사용하면 VM간에 애플리케이션을 격리하고 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스 할 수 없으므로, 일정 수준의 보안성을 제공할 수 있다.

가상화를 사용하면 물리 서버에서 리소스를 보다 효율적으로 활용할 수 있으며, 쉽게 애플리케이션을 추가하거나 업데이트할 수 있고 하드웨어 비용을 절감할 수 있어 더 나은 확장성을 제공한다. 가상화를 통해 일련의 물리 리소스를 폐기 가능한(disposable) 가상 머신으로 구성된 클러스터로 만들 수 있다.

각 VM은 가상화된 하드웨어 상에서 자체 운영체제를 포함한 모든 구성 요소를 실행하는 하나의 완전한 머신이다.

### 3) 컨테이너 개발 시대
컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제(OS)를 공유한다. 그러므로 컨테이너는 가볍다고 여겨진다. VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU 점유율, 메모리, 프로세스 공간 등이 있다. 기본 인프라와의 종속성을 끊었기 때문에, 클라우드나 OS 배포본에 모두 이식할 수 있다.

컨테이너는 다음과 같은 추가적인 혜택을 제공하기 때문에 인기가 있다.

* 기민한 애플리케이션 생성과 배포: VM 이미지를 사용하는 것에 비해 컨테이너 이미지 생성이 보다 쉽고 효율적임

* 지속적인 개발, 통합 및 배포: 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고 (이미지의 불변성 덕에) 빠르고 쉽게 롤백할 수 있다.

* 개발과 운영의 관심사 분리: 배포 시점이 아닌 빌드/릴리스 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에, 애플리케이션이 인프라스트럭처에서 분리된다.

* 가시성은 OS 수준의 정보와 메트릭에 머무르지 않고, 애플리케이션의 헬스와 그 밖의 시그널을 볼 수 있다.

* 개발, 테스팅 및 운영 환경에 걸친 일관성: 랩탑에서도 클라우드에서와 동일하게 구동된다.

* 클라우드 및 OS 배포판 간 이식성: Ubuntu, RHEL, CoreOS, 온-프레미스, 주요 퍼블릭 클라우드와 어디에서든 구동된다.

* 애플리케이션 중심 관리: 가상 하드웨어 상에서 OS를 실행하는 수준에서 논리적인 리소스를 사용하는 OS 상에서 애플리케이션을 실행하는 수준으로 추상화 수준이 높아진다.

* 느슨하게 커플되고, 분산되고, 유연하며, 자유로운 마이크로서비스: 애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포되고 관리될 수 있다.

* 리소스 격리: 애플리케이션 성능을 예측할 수 있다.

* 자원 사용량: 리소스 사용량: 고효율 고집적

## 4. Kubernetes의 필요성 및 활용성
컨테이너는 애플리케이션을 포장하고 실행하는 좋은 방법이다. 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야한다. 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야한다. 이 문제를 시스템에 의해 처리한다면 더 쉽지 않을까?

그것이 Kubernetes가 필요한 이유이다. Kubernetes는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다. 애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공한다. 예를 들어, Kubernetes는 시스템의 카나리아 배포를 쉽게 관리 할 수 있다.

Kubernetes는 다음을 제공한다.

* **서비스 디스커버리와 로드 밸런싱:** Kubernetes는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, Kubernetes는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.

* **스토리지 오케스트레이션:** Kubernetes를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.

* **자동화된 롤아웃과 롤백:** Kubernetes를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 Kubernetes를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.

* **자동화된 빈 패킹(bin packing):** 컨테이너화된 작업을 실행하는데 사용할 수 있는 Kubernetes 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 Kubernetes에게 지시한다. Kubernetes는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.

* **자동화된 복구(self-healing):** Kubernetes는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.

* **시크릿과 구성 관리:** Kubernetes를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트 할 수 있다.

## 5. Kubernetes가 아닌 것
Kubernetes는 전통적인, 모든 것이 포함된 Platform as a Service(PaaS)가 아니다. Kubernetes는 하드웨어 수준보다는 컨테이너 수준에서 운영되기 때문에, PaaS가 일반적으로 제공하는 배포, 스케일링, 로드 밸런싱과 같은 기능을 제공하며, 사용자가 로깅, 모니터링 및 알림 솔루션을 통합할 수 있다. 하지만, Kubernetes는 모놀리식(monolithic)이 아니어서, 이런 기본 솔루션이 선택적이며 추가나 제거가 용이하다. Kubernetes는 개발자 플랫폼을 만드는 구성 요소를 제공하지만, 필요한 경우 사용자의 선택권과 유연성을 지켜준다.

* **지원하는 애플리케이션의 유형을 제약하지 않는다.** Kubernetes는 상태 유지가 필요 없는(stateless) 워크로드, 상태 유지가 필요한(stateful) 워크로드, 데이터 처리를 위한 워크로드를 포함해서 극단적으로 다양한 워크로드를 지원하는 것을 목표로 한다. 애플리케이션이 컨테이너에서 구동될 수 있다면, Kubernetes에서도 잘 동작할 것이다.

* **소스 코드를 배포하지 않으며 애플리케이션을 빌드하지 않는다.** 지속적인 통합과 전달과 배포, 곧 CI/CD 워크플로우는 조직 문화와 취향에 따를 뿐만 아니라 기술적인 요구사항으로 결정된다.

* **애플리케이션 레벨의 서비스를 제공하지 않는다.** 애플리케이션 레벨의 서비스에는 미들웨어(예, 메시지 버스), 데이터 처리 프레임워크(예, Spark), 데이터베이스(예, MySQL), 캐시 또는 클러스터 스토리지 시스템(예, Ceph) 등이 있다. 이런 컴포넌트는 Kubernetes 상에서 구동될 수 있고, Kubernetes 상에서 구동 중인 애플리케이션이 Open Service Broker 와 같은 이식 가능한 메커니즘을 통해 접근할 수도 있다.

* **로깅, 모니터링 또는 경보 솔루션을 포함하지 않는다.** 개념 증명을 위한 일부 통합이나, 메트릭을 수집하고 노출하는 메커니즘을 제공한다.

* **기본 설정 언어/시스템(예, Jsonnet)을 제공하거나 요구하지 않는다.** 선언적 명세의 임의적인 형식을 목적으로 하는 선언적 API를 제공한다.

* **포괄적인 머신 설정, 유지보수, 관리, 자동 복구 시스템을 제공하거나 채택하지 않는다.**

* 추가로, **Kubernetes는 단순한 오케스트레이션 시스템이 아니다.** 사실, Kubernetes는 오케스트레이션의 필요성을 없애준다. 오케스트레이션의 기술적인 정의는 A를 먼저 한 다음, B를 하고, C를 하는 것과 같이 정의된 워크플로우를 수행하는 것이다. 반면에, Kubernetes는 독립적이고 조합 가능한 제어 프로세스들로 구성되어 있다. 이 프로세스는 지속적으로 현재 상태를 입력받은 의도한 상태로 나아가도록 한다. A에서 C로 어떻게 갔는지는 상관이 없다. 중앙화된 제어도 필요치 않다. 이로써 시스템이 보다 더 사용하기 쉬워지고, 강력해지며, 견고하고, 회복력을 갖추게 되며, 확장 가능해진다.

## 6. Kubernetes의 이점

### 1) 운영 자동화
Kubernetes에는 애플리케이션 관리에 필요한 많은 부담스러운 작업을 처리할 수 있는 명령이 기본적으로 포함되어 있으므로 이러한 명령으로 일상적인 운영을 자동화할 수 있다. 또한 애플리케이션이 항상 의도한 대로 실행되도록 할 수 있다.

### 2) 인프라 추상화
Kubernetes를 설치하면 Kubernetes가 워크로드를 대신해 컴퓨팅, 네트워킹 및 스토리지를 처리한다. 따라서 개발자는 기본 환경에 신경 쓰지 않고 애플리케이션에 집중할 수 있다.

### 3) 서비스 상태 모니터링
Kubernetes는 끊임없이 서비스 상태를 확인하여 장애가 발생하거나 중단된 컨테이너를 재시작하고, 서비스가 실행 중인 것으로 확인되었을 때만 사용자가 서비스를 사용할 수 있도록 한다

## 7. Kubernetes와 Docker
Kubernetes와 Docker는 둘 중 하나만 선택해야 하는 것으로 오해되는 경우가 많지만 사실은 컨테이너화된 애플리케이션을 실행하기 위한 서로 다르면서 보완적인 기술이다.

Docker를 사용하면 애플리케이션을 실행하는 데 필요한 모든 것을 필요할 때 언제 어디서나 저장하고 열 수 있는 컨테이너에 넣을 수 있다. 애플리케이션을 컨테이너에 넣은 후에는 애플리케이션을 관리할 방법이 필요한데 Kubernetes가 하는 일이 바로 그것이다.

Kubernetes는 영어로 'captain(선장)'을 의미하는 그리스어이다. 선장이 선박의 안전한 항해를 책임지는 것처럼 Kubernetes는 이러한 컨테이너를 사용 가능한 곳으로 안전하게 운반하여 전달할 책임이 있다.

* Kubernetes는 Docker와 함께 사용할 수도 있고 단독으로 사용할 수도 있다.

* Docker는 Kubernetes의 대안이 아니므로 'Kubernetes냐, Docker냐' 하는 것은 문제가 되지 않는다. Kubernetes와 Docker를 함께 사용하여 애플리케이션을 컨테이너화하고 대규모로 실행할 수 있다.

* Docker와 Kubernetes의 차이점은 애플리케이션 컨테이너화 및 실행 과정에서 각각이 맡는 역할과 관련이 있다.

* Docker는 애플리케이션을 컨테이너에 패키징하여 배포하기 위한 개방형 업계 표준이다.

* Kubernetes는 Docker를 사용하여 컨테이너화된 애플리케이션을 배포, 관리, 확장한다.

## 8. Kubernetes의 용도
Kubernetes는 어디서나 쉽게 관리하고 배포할 수 있는 애플리케이션을 만드는 데 사용된다. 관리형 서비스로 제공되는 Kubernetes는 사용자의 요구사항에 맞춰 다양한 솔루션을 제공한다.

### 1) 개발 속도 향상
Kubernetes는 클라우드 기반의 마이크로서비스를 기반으로 하는 앱을 빌드하는 데 유용하다. 또한 기존 앱의 컨테이너화도 지원하므로 이를 애플리케이션 현대화의 기반으로 삼아 앱을 더 빠르게 개발할 수 있다.

### 2) 위치에 구애받지 않는 애플리케이션 배포
Kubernetes는 어디서나 사용할 수 있도록 구축되어 있으므로 온사이트 배포 환경과 퍼블릭 클라우드는 물론이고 이 둘이 혼합된 하이브리드 배포 환경에서도 애플리케이션을 실행할 수 있다. 따라서 필요한 곳에서 애플리케이션을 실행할 수 있다.

### 3) 효율적인 서비스 실행
Kubernetes는 서비스 실행에 필요한 클러스터의 크기를 자동으로 조정할 수 있다. 덕분에 수요에 따라 자동으로 애플리케이션을 확장 및 축소하여 효율적으로 실행할 수 있다.

## [출처 및 참고]
* [https://kubernetes.io/ko/docs/home/](https://kubernetes.io/ko/docs/home/)
* [https://cloud.google.com/learn/what-is-kubernetes?hl=ko](https://cloud.google.com/learn/what-is-kubernetes?hl=ko)
