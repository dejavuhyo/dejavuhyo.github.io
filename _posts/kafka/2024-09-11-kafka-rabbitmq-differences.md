---
title: Kafka와 RabbitMQ의 차이점
author: dejavuhyo
date: 2024-09-11 13:19:00 +0900
categories: [Application, Architecture]
tags: [kafka-rabbitmq, kafka, rabbitmq]
---

## 1. Kafka와 RabbitMQ 특징
Kafka와 RabbitMQ는 스트림 처리에 사용할 수 있는 메시지 대기열 시스템이다. 데이터 스트림은 고속 처리가 필요한 대용량의 연속적인 증분 데이터이다.

RabbitMQ는 여러 소스에서 스트리밍 데이터를 수집하고 처리를 위해 다른 대상으로 라우팅하는 분산 메시지 브로커이다.

Apache Kafka는 실시간 데이터 파이프라인 및 스트리밍 애플리케이션을 구축하는 데 사용되는 스트리밍 플랫폼이다. Kafka는 뛰어난 확장성과 내결함성, 내구성이 뛰어난 메시징 시스템을 제공하며 RabbitMQ보다 더 많은 기능을 갖추고 있다.

## 2. 아키텍처 차이점
RabbitMQ와 Apache Kafka 둘 다 생산자가 소비자에게 메시지를 보낼 수 있다. 생산자는 정보를 게시하는 애플리케이션이고, 소비자는 정보를 구독하고 처리하는 애플리케이션이다.

![rabbitmq-kafka](/assets/img/2024-09-11-kafka-rabbitmq-differences/rabbitmq-kafka.png)

RabbitMQ와 Kafka에서 생산자와 소비자가 상호 작용하는 방식이 서로 다르다.

RabbitMQ의 생산자는 메시지를 보내고 메시지가 의도한 소비자에게 도착하는지 모니터링한다. 반면 Kafka의 생산자는 소비자가 메시지를 검색했는지 여부에 관계없이 메시지를 대기열에 게시한다.

RabbitMQ는 우편물을 받아서 수취인에게 배달하는 우체국이라고 생각하시면 된다. 반면 Kafka는 생산자가 게시하는 다양한 장르의 메시지를 진열대에 정리하는 도서관과 비슷하다. 그 후 소비자는 각 진열대에 진열된 메시지를 읽고 읽은 내용을 기억한다.

### 1) RabbitMQ 아키텍처 접근 방식
RabbitMQ 브로커는 다음 구성 요소를 사용하여 지연 시간을 줄이고 복잡한 메시지를 분산할 수 있다.

* 교환소는 생산자로부터 메시지를 수신하고 메시지를 어디로 라우팅할지 결정한다.

* 대기열은 교환소에서 메시지를 받아 소비자에게 보내는 스토리지이다.

* 바인딩은 교환소와 브로커를 연결하는 경로이다.

RabbitMQ에서 라우팅 키는 교환소에서 특정 대기열로 메시지를 라우팅하는 데 사용되는 메시지 속성이다. 생산자가 메시지를 교환소에 보낼 때 메시지에 라우팅 키가 포함된다. 그러면 교환소에서는 이 라우팅 키를 사용하여 메시지를 어느 대기열로 보낼 것인지 결정한다.

### 2) Kafka 아키텍처 접근 방식
Kafka 클러스터는 더 복잡한 아키텍처를 사용하여 처리량이 높은 스트림 이벤트를 처리한다. Kafka의 주요 구성 요소는 다음과 같다.

* Kafka 브로커는 생산자가 소비자에게 데이터를 스트리밍할 수 있게 해주는 Kafka 서버이다. Kafka 브로커에는 토픽과 해당 파티션이 포함되어 있다.

* 토픽은 유사한 데이터를 Kafka 브로커에 그룹화하는 데이터 스토리지이다.

* 파티션은 소비자가 구독하는 토픽 내의 더 작은 데이터 스토리지이다.

* ZooKeeper는 Kafka 클러스터와 파티션을 관리하여 내결함성 스트리밍을 제공하는 특수 소프트웨어이다. ZooKeeper는 최근에 Apache Kafka Raft(KRaft) 프로토콜로 대체되었다.

Kafka의 생산자는 각 메시지의 메시지 키를 할당한다. 그러면 Kafka 브로커는 해당 토픽의 선행 파티션에 메시지를 저장한다. KRaft 프로토콜은 합의 알고리즘을 사용하여 선행 파티션을 결정한다.

## 3. 메시징 처리 방식
RabbitMQ와 Apache Kafka는 서로 다른 방식으로 데이터를 생산자에서 소비자로 이동한다. RabbitMQ는 엔드투엔드 메시지 전달의 우선 순위를 지정하는 범용 메시지 브로커이다. Kafka는 지속적인 빅 데이터의 실시간 교환을 지원하는 분산 이벤트 스트리밍 플랫폼이다.

RabbitMQ와 Kafka는 서로 다른 사용 사례를 위해 설계되었으므로 서로 다른 방식으로 메시징을 처리한다. 다음으로, 구체적인 차이점이다.

### 1) 메시지 사용
RabbitMQ에서 브로커는 소비자가 메시지를 수신하게 한다. 소비자 애플리케이션은 수동적 역할을 하며 RabbitMQ 브로커가 메시지를 대기열로 푸시할 때까지 기다린다.

예를 들어 뱅킹 애플리케이션은 중앙 거래 처리 소프트웨어의 SMS 알림을 기다린다.

하지만 Kafka 소비자는 보다 선제적으로 정보를 읽고 추적한다. 메시지가 물리적 로그 파일에 추가되면 Kafka 소비자는 마지막으로 읽은 메시지를 추적하고 그에 맞게 오프셋 트래커를 업데이트한다. 오프셋 트래커는 메시지를 읽은 후 증가하는 카운터이다. Kafka를 사용하면 생산자는 소비자가 메시지를 검색하는 것을 인식하지 못한다.

### 2) 메시지 우선순위
RabbitMQ 브로커를 사용하면 생산자 소프트웨어는 우선 순위 대기열을 사용하여 특정 메시지를 에스컬레이션할 수 있다. 브로커는 선입선출 순서로 메시지를 보내는 대신 우선 순위가 높은 메시지를 일반 메시지보다 먼저 처리한다.

예를 들어 소매 애플리케이션이 1시간마다 판매 트랜잭션을 대기열에 추가할 수 있다. 그러나 시스템 관리자가 우선 순위 백업 데이터베이스 메시지를 발행하면 브로커는 해당 메시지를 즉시 전송한다.

RabbitMQ와 달리 Apache Kafka는 우선 순위 대기열을 지원하지 않는다. Apache Kafka는 메시지를 해당 파티션에 분산할 때 모든 메시지를 동등하게 취급한다.

### 3) 메시지 정렬
RabbitMQ는 메시지를 특정 순서로 보내고 대기열에 추가한다. 우선 순위가 더 높은 메시지가 시스템 대기열에 추가되지 않는 한 소비자는 전송된 순서대로 메시지를 받는다.

반면 Kafka는 토픽과 파티션을 사용하여 메시지를 대기열에 추가한다. 생산자가 메시지를 보내면 해당 메시지는 특정 토픽과 파티션으로 들어간다. Kafka는 생산자-소비자 직접 교환을 지원하지 않기 때문에 소비자는 다른 순서로 파티션에서 메시지를 끌어온다.

### 4) 메시지 삭제
RabbitMQ 브로커는 메시지를 대상 대기열로 라우팅한다. 소비자는 메시지를 읽으면 브로커에 확인(ACK) 응답을 보내고, 그러면 브로커가 대기열에서 해당 메시지를 삭제한다.

RabbitMQ와 달리 Apache Kafka는 메시지를 로그 파일에 추가하며, 메시지는 보존 기간이 만료될 때까지 보관된다. 따라서 소비자는 규정된 기간 내에 언제든지 스트리밍된 데이터를 다시 처리할 수 있다.

## 4. 기타 주요 차이점
RabbitMQ는 간단한 아키텍처로 복잡한 메시지 라우팅을 제공하는 반면, Kafka는 애플리케이션이 스트림 기록의 데이터를 처리할 수 있을 만큼 내구성이 우수한 메시지 브로커 시스템을 제공한다.

두 메시지 브로커의 차이점이다.

### 1) 성능
RabbitMQ와 Kafka 둘 다 의도한 사용 사례에 맞는 고성능 메시지 전송을 제공한다. 하지만 Kafka의 메시지 전송 용량이 RabbitMQ보다 우수하다.

Kafka는 순차 디스크 I/O를 사용하여 처리량이 높은 메시지를 교환할 수 있으므로 초당 수백만 개의 메시지를 전송할 수 있다. 순차 디스크 I/O는 인접한 메모리 공간의 데이터를 저장하고 액세스하는 스토리지 시스템으로, 임의 디스크 액세스보다 빠르다.

RabbitMQ도 초당 수백만 개의 메시지를 보낼 수 있지만, 그렇게 하려면 브로커가 여러 개 필요하다. RabbitMQ의 성능은 평균적으로 초당 수천 개의 메시지이며 RabbitMQ의 대기열이 혼잡하면 속도가 느려질 수 있다.

### 2) 보안
RabbitMQ와 Kafka를 사용하면 애플리케이션이 서로 다른 기술을 사용하여 메시지를 안전하게 교환할 수 있다.

RabbitMQ는 사용자 권한 및 브로커 보안을 관리하는 관리 도구가 함께 제공된다.

한편 Apache Kafka 아키텍처는 TLS와 Java Authentication and Authorization Service(JAAS)를 통해 안전한 이벤트 스트림을 제공한다. TLS는 의도하지 않은 메시지 도청을 방지하는 암호화 기술이고, JAAS는 브로커 시스템에 액세스할 수 있는 애플리케이션을 제어한다.

### 3) 프로그래밍 언어 및 프로토콜
Kafka와 RabbitMQ 둘 다 개발자에게 친숙한 다양한 언어, 프레임워크 및 프로토콜을 지원한다.

Kafka 및 RabbitMQ용 클라이언트 애플리케이션을 빌드할 때 Java와 Ruby로 코딩할 수 있다. 그리고 Kafka는 Python과 Node.js를 지원하는 반면, RabbitMQ는 JavaScript, Go, C, Swift, Spring, Elixir, PHP 및 .NET을 지원한다.

Kafka는 TCP를 통한 바이너리 프로토콜을 사용하여 실시간 데이터 파이프라인에서 메시지를 스트리밍하는 반면, RabbitMQ는 기본적으로 Advanced Message Queuing Protocol(AMQP)을 지원한다. RabbitMQ도 메시지를 라우팅하기 위한 Simple Text Orientated Messaging Protocol(STOMP) 및 MQTT와 같은 레거시 프로토콜을 지원한다.

## 5. 유사점
애플리케이션은 클라우드에서 데이터를 교환하려면 신뢰할 수 있는 메시지 브로커가 필요하다. RabbitMQ와 Kafka는 점점 증가하는 트래픽 수요와 고가용성을 충족하도록 확장 가능하고 내결함성이 뛰어난 플랫폼을 제공한다.

RabbitMQ와 Kafka의 주요 유사점이다.

### 1) 확장성
RabbitMQ는 메시지 처리 용량을 수평 및 수직으로 확장할 수 있다. RabbitMQ 서버에 더 많은 컴퓨팅 리소스를 할당하여 메시지 교환 효율을 높일 수 있다. 상황에 따라 개발자는 RabbitMQ 일관성 해시 교환이라는 메시지 분산 기술을 사용하여 브로커 간의 부하 처리 균형을 맞춘다.

마찬가지로 Kafka 아키텍처를 사용하면 특정 토픽에 더 많은 파티션을 추가하여 메시지 부하를 균등하게 분산할 수 있다.

### 2) 내결함성
Kafka와 RabbitMQ 둘 다 시스템 장애에 대한 복원력이 뛰어난 강력한 메시지 큐 아키텍처이다.

여러 RabbitMQ 브로커를 클러스터로 그룹화하여 여러 서버에 배포할 수 있다. 또한 RabbitMQ는 대기열에 있는 메시지를 모든 분산 노드에 복제한다. 이를 통해 시스템은 서버에 영향을 미치는 장애를 복구할 수 있다.

RabbitMQ와 마찬가지로 Apache Kafka는 Kafka 클러스터를 여러 서버에 호스팅하여 유사한 복구성과 중복성을 공유한다. 각 클러스터는 장애 발생 시 복구할 수 있는 로그 파일 복제본으로 구성된다.

### 3) 사용 편의성
두 메시지 대기열 시스템 모두 강력한 커뮤니티 지원 기능과 메시지를 간편하게 보내고 읽고 처리할 수 있는 라이브러리를 갖추고 있다. 따라서 두 시스템 모두 클라이언트 애플리케이션을 더 쉽게 개발할 수 있다.

예를 들어 Kafka Streams(클라이언트 라이브러리)를 사용하여 Kafka와 Spring Cloud Data Flow에서 메시징 시스템을 구축하여 RabbitMQ로 이벤트 기반 마이크로서비스를 구축할 수 있다.

## 6. 사용 시기
RabbitMQ와 Kafka는 서로 경쟁하는 메시지 브로커가 아니라는 점을 이해해야 한다. RabbitMQ와 Kafka는 둘 중 하나가 더 적합한 여러 사용 사례에서 데이터 교환을 지원하도록 설계되었다.

RabbitMQ 및 Kafka와 관련하여 고려해야 할 몇 가지 사용 사례이다.

### 1) 이벤트 스트림 재생
Kafka는 수신된 데이터를 다시 분석해야 하는 애플리케이션에 적합하다. 보존 기간 내에 스트리밍 데이터를 여러 번 처리할 수도 있고 로그 파일을 수집하여 분석할 수도 있다.

사용된 메시지는 삭제되기 때문에 RabbitMQ를 사용하여 로그를 집계하기는 더 어렵다. 해결 방법은 생산자가 저장한 메시지를 재생하는 것이다.

### 2) 실시간 데이터 처리
Kafka는 메시지를 스트리밍할 때 지연 시간이 매우 짧기 때문에 스트리밍 데이터를 실시간으로 분석하는 데 적합하다. 예를 들어 Kafka를 분산 모니터링 서비스로 사용하여 온라인 트랜잭션 처리 알림을 실시간으로 생성할 수 있다.

### 3) 복잡한 라우팅 아키텍처
RabbitMQ는 요구 사항이 모호하거나 라우팅 시나리오가 복잡한 클라이언트에게 유연성을 제공한다. 예를 들어 바인딩과 교환이 서로 다른 애플리케이션으로 데이터를 라우팅하도록 RabbitMQ를 설정할 수 있다.

### 4) 효과적인 메시지 전달
RabbitMQ는 푸시 모델을 적용한다. 즉, 생산자는 클라이언트 애플리케이션이 메시지를 사용했는지 여부를 알 수 있다. 데이터를 교환하고 분석할 때 특정 순서 및 전달 보장을 준수해야 하는 애플리케이션에 적합하다.

### 5) 언어 및 프로토콜 지원
개발자는 MQTT 및 STOMP와 같은 레거시 프로토콜과 호환되어야 하는 클라이언트 애플리케이션에 RabbitMQ를 사용한다. 또한 RabbitMQ는 Kafka에 비해 더 많은 프로그래밍 언어를 지원한다.

## 7. 차이점 요약

|  | RabbitMQ | Kafka |
|:-----:|:-----:|:-----:|
| 아키텍처 | RabbitMQ의 아키텍처는 복잡한 메시지 라우팅을 위해 설계되었다. 푸시 모델을 사용한다. 생산자는 다른 규칙을 사용하여 소비자에게 메시지를 보낸다. | Kafka는 처리량이 많은 스트림을 실시간으로 처리하기 위해 파티션 기반 설계를 사용한다. 풀 모델을 사용한다. 생산자는 소비자가 구독하는 토픽과 파티션에 메시지를 게시한다. |
| 메시지 처리 | RabbitMQ 브로커는 메시지 사용을 모니터링한다. 메시지가 사용되면 RabbitMQ 브로커는 사용된 메시지를 삭제한다. RabbitMQ 브로커는 메시지 우선 순위를 지원한다. | 소비자는 오프셋 트래커를 사용하여 메시지 검색을 추적한다. Kafka는 보존 정책에 따라 메시지를 보관한다. 메시지 우선 순위가 없다. |
| 성능 | RabbitMQ는 지연 시간이 짧다. 초당 수천 개의 메시지를 전송한다. | Kafka는 초당 최대 수백만 개의 메시지를 실시간으로 전송한다. |
| 프로그래밍 언어 및 프로토콜| RabbitMQ는 광범위한 언어 및 레거시 프로토콜을 지원한다. | Kafka는 프로그래밍 언어 선택의 폭이 제한적이다. TCP를 통한 바이너리 프로토콜을 데이터 전송에 사용한다. |

## [출처 및 참고]
* [https://aws.amazon.com/ko/compare/the-difference-between-rabbitmq-and-kafka/](https://aws.amazon.com/ko/compare/the-difference-between-rabbitmq-and-kafka/)
* [https://www.aalpha.net/blog/rabbitmq-vs-kafka-for-microservices/](https://www.aalpha.net/blog/rabbitmq-vs-kafka-for-microservices/)
